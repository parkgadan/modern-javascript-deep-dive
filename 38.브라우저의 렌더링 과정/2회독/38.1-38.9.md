# 38장 브라우저 렌더링 과정

- 구글의 V8 자바스크립트 엔진으로 빌드 된 자바스크립트 런타임 환경 **Node.js** 의 등장으로 자바스크립트는 **서버 사이드 애플리케이션**에도 쓸 수 있는 범용 개발 언어가 되었다.
    - 하지만 자바스크립트는 대부분 **웹 브라우저 환경**에서 동작하는 웹페이지/앱의 **클라이언트 사이드**에 사용된다.
- 대부분의 프로그래밍 언어는 **OS**나 **VM** 위에서 실행되지만, 클라이언트 사이드 자바스크립트는 **브라우저에서 HTML, CSS와 함께 실행**된다.
- 브라우저가 HTML, CSS, 자바스크립트로 작성된 텍스트 문서를 어떻게 파싱하여 렌더링 하는지 살펴보자.
    - `**파싱**`: 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적인 의미와 구조를 반영하여 `트리 구조`의 `파스 트리`를 생성하는 과정.
    파싱 완료 후 파스 트리를 기반으로 **중간 언어(`바이트 코드`)**를 생성하고 실행 한다.
    - `**렌더링` :** HTML, CSS, JS 문서를 파싱하여 브라우저에 **시각적**으로 출력하는 것.

### 브라우저의 간략한 렌더링 과정

1. HTML, CSS, JS, Image, Font … 등 렌더링에 필요한 소스를 요청하고 서버로부터 응답을 받음
2. `**브라우저의 자바스크립트 엔진**`은 HTML, CSS를 파싱하여 DOM과 CSSOM을 생성하고 결합하여 `**렌더 트리**`를 생성한다.
3. `**브라우저의 렌더링 엔진**`은 서버로부터 응답 된 JS를 파싱하여 `**AST**`(Abstract Syntax Tree)를 생성하고 **바이트 코드**로 변환하여 실행한다.
    1. 이 때 JS는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다.
    2. 변경된 DOM과 CSSOM은 `렌더 트리`로 다시 결합한다.
4. 렌더 트리를 기반으로 요소의 `레이아웃`을 계산하고, 브라우저 화면에 HTML 요소를 `페인팅`한다.

# 38.1 요청과 응답

- 브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고 응답받아 브라우저에 시각적으로 렌더링 하는 것이다.
- 렌더링에 필요한 **리소스는 서버에 존재**하므로 서버가 응답한 리소스를 파싱하여 렌더링한다.
- 브라우저의 **주소창**을 통해 서버에 요청을 전송한다.
    - URL을 입력하고 엔터 키를 누르면,
        1. URL 호스트 이름이 DNS를 통해 **IP 주소로 변환**되고
        2. 이 **IP 주소를 갖는 서버에게 요청을 전송**한다.
- 서버는 루트 요청에 대해 암묵적으로 `index.html`을 클라이언트로 응답한다.
    - ex) https://poiemaweb.com ⇒ https://poiemaweb.com/index.html
- **index.html 이 아닌 정적 파일을 요청**하려면 `정적 파일의 경로`와 `파일 이름`을 host 뒤의 path에 기술하여 서버에 요청한다.
    - ex) https://poiemaweb.com/assets/data/**`data.json`**
- 브라우저 주소창 외에도 자바스크립트를 통해 동적으로 서버에 데이터를 요청할 수도 있다.
    - ex) 43장 ajax, 44장 REST API
- 요청과 응답은 개발자 도구의 `Network 탭`에서 확인할 수 있다.
    - Network 탭을 확인하면, index.html 외에도 CSS, JS, Image, Font 등의 파일들도 응답 된다.
        
        ⇒ index.html을 파싱하는 도중에 **외부 리소스를 로드하는 태그(CSS - <link/>, Image - <img/>, JS - <script /> )**들을 만나면 **HTML 파싱을 중단**하고 리소스 파일을 서버로 요청하기 때문이다.
        

# 38.2 HTTP 1.1과 HTTP 2.0

- HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다.
    - 1991년: HTTP 최초 문서화
    - 1996년: HTTP/1.0
    - 1999년: HTTP/1.1
    - 2015년: HTTP/2

### HTTP/1.1과 HTTP/2의 차이점

- HTTP/1.1
    - 커넥션 당 하나의 요청과 응답만 처리
    - HTML 문서 내에 포함 된 여러 개의 리소스 요청**(CSS - <link/>, Image - <img/>, JS - <script /> )**들은 개별적으로 전송되고 응답도 개별적으로 전송된다.
    - 리소스의 동시 전송이 불가능한 구조이므로 **요청할 리소스 개수에 비례하여 응답 시간도 증가하는 단점이 있다.**
- HTTP/2
    - 커넥션 당 여러 개의 요청과 응답이 가능하다.
        - **여러 리소스의 동시 전송이 가능**해 HTTP/1.1보다 페이지 로드 속도가 약 50% 정도 빠르다.

# 38.3 HTML 파싱과 DOM 생성

- HTML 문서는 문자열로 이루어진 순수한 **텍스트**이므로, 시각적인 픽셀로 렌더링하려면 브라우저가 이해할 수 있는 **자료구조(객체)**로 변환하여 메모리에 저장해야 한다.
    1. 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음**, 메모리에 저장된 바이트(2진수**)를 인터넷을 경유하여 **응답**한다.
    2. 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수)형태로 응답 받는다. 그리고 응답 된 바이트 형태의 HTML 문서는 **`meta 태그의 charset 어트리뷰트`**에 의해 지정된 인코딩 방식(ex. UTF-8)을 기준으로 **문자열로 변환**된다.
        1. 인코딩 방식은 **응답 헤더**에 담겨 응답 된다.
    3. 문자열로 변환된 HTML 문서를 문법적 의미를 갖는 코드의 최소 단위인 `토큰`들로 분해한다.
    4. 토큰들을 객체로 변환해 `노드`들을 생성한다. 노드는 이후 DOM을 구성하는 기본 요소가 된다.
        1. 문서 노드
        2. 요소 노드
        3. 어트리뷰트 노드
        4. 텍스트 노드
    5. HTML 문서는 HTML 요소들의 집합으로 이루어지며, HTML 요소는 **중첩 관계**를 갖는다.
        1. HTML 요소의 콘텐츠 영역에는 텍스트 뿐만 아니라 다른 HTML 요소가 포함될 수 있다.
        2. 이러한 부자 관계를 반영하여 모든 노드들을 **트리 자료구조로 구성(DOM)**한다.
- 즉, DOM은 **HTML을 파싱한 결과물**이다.

# 38.4 CSS 파싱과 CSSOM 생성

- 렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성한다.
- DOM을 생성해 나가다 link 태그나 style 태그를 만나면 DOM 생성을 일시 중단한다.
- link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청하여 로드한 CSS 파일이나 style 태그 내의 CSS를 **HTML과 동일한 파싱 과정** `(바이트 → 문자 → 토큰 → 노드 → CSSOM)`을 거치며 해석하여 `**CSSOM**`을 생성한다.
- CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.
- CSSOM은 CSS의 상속을 반영하여 생성된다.
    - ex) body요소에 적용한 font-size나 list-style-type 프로퍼티는 모든 li 요소에 상속된다.

# 38.5 렌더 트리 생성

- 브라우저의 렌더링 인젠이 HTML과 CSS를 각각 파싱하여 DOM과 CSSOM을 생성한다.
    - DOM과 CSSOM은 렌더링을 위해 **`렌더 트리`**로 결합된다.
- ⭐ 렌더 트리는 렌더링을 위한 트리 구조의 자료 구조다. 따라서 **화면에 렌더링 되지 않는 노드(script, meta)**와 **CSS에 의해 비표시 되는 노드(display: none;)**들은 포함하지 않는다.
- 렌더 트리는 HTML요소의 각 **`레이아웃(위치와 크기)을 계산`**하는 데 사용되며, 브라우저 화면에 픽셀을 렌더링하는 `**페인팅 처리**`에 입력된다.
- 브라우저 렌더링 과정은 반복돼서 실행될 수 있다.
    - 레이아웃 계산과 페인팅이 재차 실행(**`리렌더링`**)되는 경우
        - 자바스크립트에 의한 노드 추가 또는 삭제
        - 브라우저 창 리사이징에 의한 뷰포트 크기 변경
        - HTML 요소의 레이아웃 변경을 발생시키는 스타일 변경
            - width/height, margin, padding, border, display, position, top, right, bottom, left …
- **⭐ 레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 성능에 악영향을 주는 작업이다. 리렌더링이 빈번하게 발생하지 않게 주의한다.**

# 38.6 자바스크립트 파싱과 실행

- HTML을 파싱한 결과물로 생성된 DOM은 HTML 문서의 구조와 정보, HTML 요소와 스타일 등을 변경할 수 있는 **DOM API**를 제공한다.
- **DOM API**를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.
- CSS 파싱 과정과 마찬가지로 **`렌더링 엔진`**은 HTML을 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나가다가  **script 태그**를 만나면 **DOM 생성을 일시 중단**한다.
    - script 태그의 자바스크립트 코드를 파싱하기 위해 `**자바스크립트 엔진**`에 제어권을 넘긴다.
    - 자바스크립트 파싱과 실행이 종료되면 다시 **`렌더링 엔진`**으로 제어권을 넘겨 HTML 파싱이 중단된 시점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다.

### 브라우저의 자바스크립트 엔진

- 자바스크립트의 **파싱과 실행**을 처리한다.
- 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 **저수준 언어**로 변환하고 실행한다.
- **자바스크립트 엔진의 종류**
    - 구글 크롬과 Node.js의 `V8`
    - 파이어폭스의 `SpiderMonkey`
    - 사파리의 `JavaScriptCore`
    - 모든 자바스크립트 엔진은 ECMASCript 사양을 준수한다.
- 자바스크립트 엔진은 렌더링 엔진이 DOM과 CSSOM을 생성하듯, 자바스크립트를 해석하여 **`AST`**를 생성한다.
- AST를 기반으로 `인터프리터`가 실행할 수 있는 중간 코드인 `**바이트 코드**`를 생성하여 실행한다.

<aside>
💡 Javscript 소스 코드 → `토크나이징` → 토큰 → `파싱` → AST → `바이트 코드 생성` → 바이트 코드 → `실행` → 인터프리터

</aside>

### 토크나이징

- 단순한 문자열인 Javascript 소스 코드를 어휘 분석하여 문법적 의미를 갖는 코드의 최소 단위인 `**토큰`들로 분해**한다.
- `렉싱`이라고도 하지만 토크나이징과 미묘한 차이가 있다.

### 파싱

- 토큰들의 집합을 구문 분석하여 **`AST(추상적 구문 트리)`**를 생성한다.
    - `AST`: **토큰에 문법적 의미와 구조를 반영한** **트리 구조**의 자료 구조.
- AST를 사용하면 TypeScript, Babel, Prettier 같은 **트랜스파일러를 구현**할 수 있다.
- AST Explorer 웹사이트에서 다양한 오픈소스 자바스크립트 파서를 사용해 AST를 생성해 볼 수 있다.
    - [https://astexplorer.net](https://astexplorer.net/)

### 바이트 코드 생성과 실행

- AST는 인터프리터가 실행할 수 있는 중간 코드인 `바이트 코드`로 변환되고 인터프리터에 의해 실행된다.
- * **`V8 엔진`**의 경우: `터보팬`이라는 컴파일러에 의해 최적화된 `머신 코드`로 컴파일 되어 성능을 최적화한다. 코드의 사용 빈도가 적어지면 다시 디옵티마이징 하기도 한다.

# 38.7 리플로우와 리페인트

- JS 코드에 DOM과 CSSOM을 변경하는 **DOM API**가 사용된 경우 DOM이나 CSSOM이 변경된다.
- 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃`(리플로우)`과 페인트 과정`(리페인트)`을 거쳐 다시 렌더링 된다.
    - 리플로우: 레이아웃 계산을 다시 하는 것
        - 노드의 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등
    - 리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것.
- 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행된다.

# 38.8 자바스크립트 파싱에 의한 HTML 중단

- 렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고 **직렬적으로** 파싱을 수행한다.
- 브라우저는 **`동기적`**으로 HTML, CSS, JS를 파싱하고 실행한다.
- **script 태그의 위치에 따라** HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다.

### Javascript를 body 요소 가장 아래에 위치 시키는 이유

- 만약 파싱 중에 만난 자바스크립트 코드 안에 DOM API를 사용할 경우 DOM이나 CSSOM이 이미 생성되어 있어야 한다.
    - DOM이 완성되지 않은 상태에서 JS가 DOM을 조작하면 **에러가 발생할 수 있다.**
- body 아래에 JS를 위치시키면, HTML 요소들의 렌더링에 JS 로딩/파싱/실행으로 지장 받는 일이 발생하지 않아 **페이지 로딩 시간이 단축된다.**

# 38.9 script 태그의 async/defer 어트리뷰트

- HTML5부터 script 태그에 async와 defer 어트리뷰트가 추가되었다.
- async와 defer은 src 어트리뷰트를 통해 외부 JS 파일을 로드하는 경우에만 사용할 수 있다.
    - 즉, 인라인 자바스크립트에는 사용할 수 없다.
    - async와 defer를 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 하지만 **`자바스크립트의 실행 시점`**에 차이가 있다.

### async 어트리뷰트

- HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 **동시에** 진행된다.
- 자바스크립트의 파싱과 실행은 JS 파일의 로드가 완료된 직후 진행된다. 이때 **HTML 파싱이 중단**된다.
- **script 태그 순서 보장이 되지 않으므로 순서 보장이 필요한 script 태그에는 async 어트리뷰트를 지정하지 않아야 한다.**

### defer 어트리뷰트

- HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 **동시에** 진행된다.
- 자바스크립트의 파싱과 실행은 **HTML 파싱이 완료된 직후** 진행된다. 따라서 **DOM 생성이 완료된 직후 실행되어야 할 자바스크립트**에 유용하다.