# 26장 ES6 함수의 추가 기능


## 목차

- [26.1 함수의 구분](#26.1)
- [26.2 메서드](#26.2)
- [26.3 화살표 함수](#26.3)
  - [26.3.1 화살표 함수 정의](#26.3.1)
  - [26.3.2 화살표 함수와 일반 함수의 차이](#26.3.2)
  - [26.3.3 this](#26.3.3)
  - [26.3.4 super](#26.3.4)
  - [26.3.5 arguments](#26.3.5)
- [26.4 Rest 파라미터](#26.4)
  - [26.4.1 기본 문법](#26.4.1)
  - [26.4.2 Rest 파라미터와 arguments 객체](#26.4.2)
- [26.5 매개변수 기본값](#26.5)


## 26.1 함수의 구분<a name="26.1"></a>

- ES6 이전까지 자바스크립트의 함수
	- 별다른 구분 없이 다양한 목적으로 사용하여, 호출 방식에 특별한 제약이 없으며 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성함
	- callable이면서 constructor이었음
	- 일반적인 함수로서 호출 가능
	- new 연산자와 함께 호출하여 생성자 함수(인스턴스 생성할 수 있음)로서 호출 가능
	- 객체에 바인딩되어 메서드로서 호출 가능
	- 메서드라고 부르던 객체에 바인딩된 함수도 callable이면서 constructor이었음
	- 객체에 바인딩된 함수도 일반 함수로서 호출 가능했으며, 생성자 함수로서 호출 가능했음
	- 객체에 바인딩된 함수를 생성자 함수로 호출하는 게 문법상 가능했음. 이는 성능면에서도 문제가 존재
		- 객체에 바인딩된 함수가 constructor라는 것은 객체에 바인딩된 함수가 prototype 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미하기 때문
	- 콜백 함수(함수에 전달되어 보조 함수 역할 수행)도 마찬가지로, constructor이기 때문에 불필요한 프로토타입 객체를 생성함

```js
var foo = function () { 
	return 1; 
}; 

// 일반적인 함수로서 호출
foo(); // 1 

// 생성자 함수로서 호출
new foo(); // foo {} 

// 메서드로서 호출
var obj = { foo: foo }; 
obj.foo(); // 1
```

- callable과 constructor/non-constructor
	- callable: 호출할 수 있는 함수 객체
	- constructor: 인스턴스를 생성할 수 있는 함수 객체
	- non-constructor: 인스턴스를 생성할 수 없는 함수 객체

- ES6에서의 함수 구분
	- 일반 함수
		- 함수 선언문, 함수 표현식으로 정의한 함수
		- ES6 이전의 함수와 차이 없음
		- constructor
	- ES6의 메서드와 화살표 함수
		- non-constructor

|ES6 함수의 구분|constructor|prototype|super|arguments|
|--|--|--|--|--|
|일반 함수(Normal)|O|O|X|O|
|메서드(Method)|X|X|O|O|
|화살표 함수(Arrow)|X|X|X|X|


## 26.2 메서드<a name="26.2"></a>

- ES6 이전 메서드
	- 명확한 정의 X
	- 객체에 바인딩된 함수를 일컫는 의미로 사용

- ES6에서의 메서드
	- 메서드 축약 표현으로 정의된 함수만 의미
	- 인스턴스를 생성할 수 없는 non-constructor
	- 생성자 함수로서 호출 불가능
	- prototype 프로퍼티 없음
	- 프로토타입 생성 안함
	- 객체가 제공하는 프로토타입 메서드와 정적 메서드 모두 non-constructor
	- 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 가짐
	- super 참조는 내부 슬롯 `[[HomeObject]]`를 사용하여 수퍼클래스의 메서드를 참조하기 때문에 super 키워드 사용 가능
		- ES6 메서드가 아닌 함수는 내부 슬롯 `[[HomeObject]]`를 갖지 않아, super 키워드 사용 불가

```js
const obj = { 
	x: 1, 
	
	// foo는 메서드
	foo() { return this.x; }, 
	// bar에 바인딩된 함수는 메서드가 아닌 일반 함수
	bar: function() { return this.x; } 
};

console.log(obj.foo()); // 1 
console.log(obj.bar()); // 1
```


## 26.3 화살표 함수<a name="26.3"></a>

- 화살표를 사용하여 기존의 함수 정의 방식보다간략하게 함수 정의 가능
- 내부 동작도 기존 함수보다 간략함
- 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용

### 26.3.1 화살표 함수 정의<a name="26.3.1"></a>

- 함수 정의
	- 함수 선언문으로 정의 불가능
	- 함수 표현식으로 정의 가능
	- 기존 함수와 호출 방식 동일

- 매개변수 선언
	- 매개변수가 여러 개인 경우, 소괄호 () 안에 매개변수 선언
	- 매개변수가 한 개인 경우, 소괄호 () 생략 가능
	- 매개변수 없는 경우, 소괄호 () 생략 불가능

- 함수 몸체 정의
	- 함수 몸체가 하나의 문으로 구성되는 경우, 함수 몸체를 감싸는 중괄호 {} 생략 가능
	- 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식의 문인 경우 암묵적으로 반환됨
	- 함수 몸체를 감싸는 중괄호 {} 생략한 경우, 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생함
	- 표현식이 아닌 문은 반환할 수 없음
	- 함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호 생략 불가능
	- 객체 리터럴 반환하는 경우, 객체 리터럴을 소괄호 ()로 감싸야 함
		- 감싸지 않는 경우, 객체 리터럴 중괄호 {}를 함수 몸체를 감싸는 중괄호 {}로 잘못 해석함
	- 함수 몸체가 여러 개의 문으로 구성된 경우, 함수 몸체를 감싸는 중괄호 {} 생략 불가능
		- 반환값이 있는 경우 명시적으로 반환해야 함
	- 화살표 함수도 즉시 실행 함수로 사용 가능
	- 화살표 함수는 일급 객체이므로 고차 함수에 인수로 전달 가능
	
```js
// concise body 
const power = x => x ** 2; 
power(2); // 4 

// 위 표현은 다음과 동일 
// block body 
const power = x => { return x ** 2; };
```

### 26.3.2 화살표 함수와 일반 함수의 차이<a name="26.3.2"></a>

1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor

```js
	const Foo = () => {}; 
// 화살표 함수는 생성자 함수로서 호출 불가 
new Foo(); // typeError
```

2. 중복된 매개변수 이름을 선언 불가

3. 화살표 함수는 함수 자체의 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않음
	- 함수 내부에서 `this`, `arguments`, `super`, `new.target` 참조 시, 스코프 체인을 통해 상위 스코프의 `this`, `arguments`, `super`, `new.target` 참조함


### 26.3.3 this<a name="26.3.3"></a>

- 화살표 함수가 일반 함수와 구별되는 가장 큰 특징
- 다른 함수의 인수로 전달되어 콜백 함수로 사용되는 경우 많음
- 콜백 함수 내부의 this가 외부 함수의 this와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계됨
- 함수의 호출 방식(함수가 어떻게 호출되었는지)에 따라 동적으로 결정됨
- 함수 정의할 때, this에 바인딩할 객체가 정적으로 결정되는 것이 아닌, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정됨
- 주의 사항
	- 일반 함수로서 호출되는 콜백 함수의 경우, 고차 함수의 인수로 전달되어 고차 함수 내부에서 호출되는 콜백 함수도 중첩 함수가 됨

```js
class Prefixer { 
	constructor(prefix) { 
		this.prefix = prefix; 
	} 

	add(arr) { 
	// add 메서드는 인수로 전달된 배열 arr을 순회하며 배열의 모든 요소에 prefix 추가 
	// (1)
		return arr.map(function (item) { 
			return this.prefix + item; // (2
			// TypeError: Cannot read property 'prefix' of undefined 
		});
	}
}

const prefixer = new Prefixer('-webkit-'); 
console.log(prefixer.add([transition', 'user-select']));
```

- Array.prototype.map 메서드
	- 배열을 순회하며 배열의 각 요소에 대해 인수로 전달된 콜백 함수 호출함
	- 콜백 함수의 반환값들로 구성된 새로운 배열을 반환함

- 콜백 함수 내부의 this 문제 해결 방법
	- ES6 이전
		1. add 메서드를 호출한 prefixer 객체를 가리키는 this를 일단 회피시킨 후, 콜백 함수 내부에서 사용
		2. `Array.prototype.map`의 두 번째 인수로 add 메서드를 호출한 prefixer 객체를 가리키는 this 전달
		3. `Function.prototype.bind` 메서드 사용하여 add 메서드를 호출한 prefixer 객체를 가리키는 this 바인딩
	- ES6
		- 화살표 함수 사용
			- 함수 자체의 this 바인딩을 갖지 않아, 화살표 함수 내부에서 this 참조 시 상위 스코프의 this를 그대로 참조함(=lexical this)

```js
// ES6의 콜백 함수 내부의 this 문제 해결 방법
class Prefixer { 
	constructor(prefix) { 
		this.prefix = prefix; 
} 

	add(arr) { 
		return arr.map(item => this.prefix + item); 
	} 
} 

const prefixer = new Prefixer('-webkit-'); 
console.log(prefixer.add(['transition'，’user-select'])); 
// ['-webkit-transition', '-webkit-user-select']
```

- 화살표 함수를 제외한 모든 함수에는 this 바인딩이 존재
- 화살표 함수 중첩 시, 상위 화살표 함수에도 this 바인딩이 존재하지 않아, 스코프 체인 상에서 가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 this를 참조
- 화살표 함수가 전역 함수 시, 화살표 함수의 this는 전역 객체를 가리킴
	- 전역 함수의 상위 스코프는 전역이며, this는 전역 객체릴 가리키기 때문
- 프로퍼티에 할당한 화살표 함수도 스코프 체인 상에서 가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 this 참조
- 함수 자체의 this 바인딩을 갖지 않기 때문에 `Function.prototype.call`, `Function.prototype.apply`, `Function.prototype.bind` 메서드를 사용해도 화살표 함수 내부의 this 교체 불가
	- `Function.prototype.call`, `Function.prototype.apply`, `Function.prototype.bind` 메서드 호출은 가능
	- this 바인딩을 갖지 않아 this 교체는 불가능하며, 상위 스코프의 this 바인딩을 참조

- 메서드를 화살표 함수로 정의하는 것은 피해야 함
- 프로퍼티를 동적 추가 시, ES6 메서드 정의를 사용할 수 없어 일반 함수를 할당함
- ES6 메서드를 동적 추가하고 싶은 경우, 객체 리터럴을 바인딩하고 프로토타입의 constructor 프로퍼티와 생성자 함수 간의 연결 재설정 필요
- 클래스 필드 정의 제안 사용하여, 클래스 필드에 화살표 함수 할당 가능
- 메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋음


### 26.3.4 super<a name="26.3.4"></a>

- 화살표 함수는 함수 자체의 super 바인딩을 갖지 않음
- super 참조 시, this와 마찬가지로 상위 스코프의 super 참조
- 내부 슬롯 `[[HomeObject]]`를 갖는 ES6 메서드 내에서만 사용할 수 있는 키워드

### 26.3.5 arguments<a name="26.3.5"></a>

- 함수 자체의 arguments 바인딩을 갖지 않음
- 화살표 함수 내부에서 arguments 참조 시, this와 마찬가지로 상위 스코프의 arguements 참조함
- 상위 스코프의 arguments 객체 참조는 가능하나, 화살표 함수 자신에게 전달된 인수 목록을 확인할 수 없고, 상위 함수에게 전달된 인수 목록을 참조하여 도움이 되지 않음
- 가변 인자 함수 구현 시, 반드시 Rest 파라미터 사용해야 함


## 26.4 Rest 파라미터<a name="26.4"></a>

### 26.4.1 기본 문법<a name="26.4.1"></a>

- 매개변수 이름 앞에 세개의 점 `...`을 붙여서 정의한 매개변수 의미
- Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받음
- 일반 매개변수와 함께 사용 가능
	- 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당됨
- 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당되기 때문에 반드시 마지막 파라미터이어야 함
- 단 하나만 선언 가능
- 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향 안 줌

```js
function foo(... rest) { 
	// 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터 
	console.log(rest); // [ 1, 2, 3, 4, 5 ] 
} 

food(1, 2, 3, 4, 5);
```

### 26.4.2 Rest 파라미터와 arguments 객체<a name="26.4.2"></a>

- 매개변수를 통해 인수 전달받는 것은 불가능
- arguments 객체를 활용해 인수 전달 받음
- 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체
- 함수 내부에서 지역 변수처럼 사용 가능
- arguments 객체는 배열이 아닌 유사 배열 객체이므로 배열 메서드 사용 시, `call`/`apply` 메서드를 사용해 arguements 객체를 배열로 변환해야 함
- 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 함


## 26.5 매개변수 기본값<a name="26.5"></a>

- 매개변수의 개수만큼 인수를 전달하는 것이 바람직하지만 그렇지 않은 경우에도 에러가 발생하지 않음
	- 자바스크립트 엔진이 매개변수의 개수와 인수의 개수를 체크하지 않기 때문
	- 인수가 전달되지 않은 매개변수 값은 `undefined`
- 매개변수에 인수가 전달되었는지 확인 후 인수 전달 안된 경우, 매개변수에 기본값 할당 필요(방어 코드 필요함)
- 매개변수 기본값 사용 시 함수 내에 수행하던 인수 체크 및 초기화 간소화 가능
- 매개변수 기본값은 매개변수에 인수를 전달하지 않은 경우와 undefined 전달한 경우에만 유효
- Rest 파라미터에는 기본값 지정 불가
- 매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티와 arguments 객체에 영향 못 줌