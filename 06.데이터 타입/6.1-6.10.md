# 6장 데이터 타입

## 목차
- [숫자 타입](#6.1)
- [문자열 타입](#6.2)
- [템플릿 리터럴](#6.3)
  - [멀티라인 문자열](#6.3.1)
  - [표현식 삽입](#6.3.2)
- [불리언 타입](#6.4)
- [undefined 타입](#6.5)
- [null 타입](#6.6)
- [심벌 타입](#6.7)
- [객체 타입](#6.8)
- [데이터 타입의 필요성](#6.9)
  - [데이터 타입에 의한 메모리 공간의 확보와 참조](#6.9.1)
  - [데이터 타입에 의한 값의 해석](#6.9.2)
- [동적 타이핑](#6.10)
  - [동적 타입 언어와 정적 타입 언어](#6.10.1)
  - [동적 타입 언어와 변수](#6.10.2)

## 6.1 숫자 타입<a name="6.1"></a>

- 배정밀도 64비트 부동소수점 형식
  - 모든 수를 실수로 처리
    ```js
    console.log(1 === 1.0); // true
    console.log(4 / 2); // 2
    ```
  - 정수만 표현하기 위한 데이터 타입은 존재하지 않음
    - 정수
      ```js
      var integer = 10;
      ```
    - 실수
      ```js
      var double = 10.12;
      ```
    - 음의 정수 
      ```js
      var negative = -20;
      ```
- 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장
  - 2진수, 8진수, 16진수 표현하기 위한 데이터 타입 제공 안함
    ```js
    var binary = 0b01000001; // 2진수
    var octal = 0ol01; // 8진수
    var hex = 0x41; // 16진수
    ```
  - 값 참조 시, 10진수로 해석됨
    ```js
    consol.log(binary); // 65
    console.log(octal); // 65
    console.log(binary === octal); // true
    ```
- 특별한 값 표현 가능
  - `Infinity`
    - 양의 무한대
    ```js
    console.log(10 / 0);
    ```
  - `-Infinity`
    - 음의 무한대
    ```js
    console.log(10 / -0);
    ```
  - `NaN`
    - 산술 연산 불가(not-a-number)
    ``` js
    console.log(1 * 'String');
    ```


## 6.2 문자열 타입<a name="6.2"/></a>

- 텍스트 데이터 표현 시 사용, 원시타입이며 변경 불가능한 값
- 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자 표현
- 작은따옴표(`''`), 큰따옴표(`""`), 백틱(<code>``</code>)으로 텍스트를 감싸서 문자열 타입을 표현 <br/>
  ```js
  var string;
  string = '문자열';
  string = "문자열";
  string = `문자열`;
  ```
  - 따옴표로 감싸지않은 텍스트는 키워드, 식별자 같은 **토큰**으로 인식


## 6.3 템플릿 리터럴<a name="6.3"></a>

- 백틱(<code>``</code>)을 사용해 표현
  - 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등
  ```js
  var template = `Template literal`;
  ```
- 런타임에 일반 문자열로 변환되어 처리됨
- ES6부터 도입된 새로운 문자열 표기법

### 6.3.1 멀티라인 문자열<a name="6.3.1"></a>

- 이스케이프 스퀀시(백슬래시(`\`)로 시작함)를 사용하지 않고 줄바꿈 허용
- 모든 공백 허용
  ```js
  var template = `<ul>
    <li><a href="#">Home</a></li>
  <url>`;

  // print
  <ul>
    <li><a href="#">Home</a></li>
  </ul>
  ```

### 6.3.2 표현식 삽입<a name="6.3.2"></a>

- `${}`으로 표현식을 감싸여 사용
  - 템플릿 리터럴 내에서 사용 가능
  - 평가 결과는 문자열로 타입이 강제 변환되어 삽입됨
  ```js
  console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
  ```


## 6.4 불리언 타입<a name="6.4"></a>

- 논리적 참(`true`), 거짓(`false`)
- 조건문에서 주로 사용


## 6.5 undefined 타입<a name="6.5"></a>

- `undefined` 값만 존재
- `var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화됨
  - 할당이 이뤄질 때까지 `undefined` 유지
  - 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값


## 6.6 null 타입<a name="6.6"></a>

- `null` 값만 존재
- 변수에 값이 없다는 것을 의도적으로 명시할 때 사용
  - 변수에 `null` 할당 시, 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거함


## 6.7 심벌 타입<a name="6.7"></a>

- 변경 불가능한 원시 타입의 값으로, 다른 값과 중복되지 않는 유일무이한 값
- 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- `Symbol` 함수 호출하여 생성
  - 생성된 심벌 값은 외부에 노출되지 않음
```js
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol
```


## 6.8 객체 타입<a name="6.8"></a>

- 데이터 타입의 분류
  - 원시 타입
  - 객체 타입
- 자바스크립트를 이루고 있는 거의 모든 것은 객체이다.


## 6.9 데이터 타입의 필요성<a name="6.9"></a>

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조<a name="6.9.1"></a>

- 메모리 공간 확보
  - 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정됨
  - 문자열과 숫자 타입을 제외하고 데이터 타입에 따라 확보되는 메모리 공간 크기는 자바스크립트 엔진 제조사의 구현에 따라 다름
- 값 참조
  - 값 참조 시, 메모리 공간의 크기(메모리 셀의 개수, 바이트 수) 필요
- 심벌 테이블
  - 자료 구조
  - 컴파일러 또는 인터프리터는 심벌 테이블을 이용하여 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리함.

### 6.9.2 데이터 타입에 의한 값의 해석<a name="6.9.2"></a>

- 데이터 타입이 필요한 이유
  - 값 저장 시, 확보해야 하는 메모리 공간의 크기 결정을 위해
  - 값 참조 시, 한 번에 읽어 들여야 할 메모리 공간의 크기 결정을 위해
  - 메모리에서 읽어 들인 2진수 해석 결정을 위해


## 6.10 동적 타이핑<a name="6.10"></a>

### 6.10.1 동적 타입 언어와 정적 타입 언어<a name="6.10.1"></a>
- 정적 타입 언어
  - C, C++, 자바, 코틀린, go, 하스켈, 러스트 등
  - 데이터 타입을 사전에 선언해야 함
  - 변수의 타입 변경 불가능
  - 컴파일 시점에 타입 체크를 수행함
    - 타입 체크 실패 시, 에러가 발생하며 프로그램의 실행이 불가능함
    - 타입의 일관성을 강제하여 런타임에 발생하는 에러를 줄임
- 동적 타입 언어
  - 자바스크립트, 파이썬, 루비 등
  - 값을 할당하는 시점에 변수의 타입이 동적으로 결정
  - 변수의 타입은 언제든지 자유롭게 변경 가능
    - 선언이 아닌 할당에 의해 타입 결정됨(타입 추론)
  - 변수는 타입을 가지지 않으며, 값은 타입을 가짐

### 6.10.2 동적 타입 언어와 변수<a name="6.10.2"></a>

- 유연성은 높으나 신뢰성이 떨어져, 변수 사용 시 주의 사항 존재
  - 제한적으로 변수 사용
  - 변수 값은 재할당에 의해 언제든지 변경 가능
  - 변수의 스코프를 최대한 좁게 만들어야 함
  - 전역 변수는 최대한 사용하지 않음
  - 상수를 사용해 값의 변경을 억제함
  - 변수의 목적이나 의미를 파악할 수 있도록 변수 이름을 네이밍함
